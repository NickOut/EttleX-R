schema_version: 0
project:
  name: ettlex
ettles:
- id: ettle:root
  title: EttleX Product
  eps:
  - id: ep:root:0
    ordinal: 0
    normative: false
    why: 'Establish the product-level framing for EttleX as a semantic evolution engine.

      This EP is non-load-bearing for the storage/commit milestones; it exists to keep the tree rooted in a

      recognisable product-level node for rendering and navigation.

      '
    what: 'Maintain a minimal product framing so leaf Ettles can be rendered in context.

      This EP does not impose implementation requirements on Phase 1/2 milestones.

      '
    how: 'No scenarios. This EP is informational only.

      '
  - id: ep:root:1
    ordinal: 1
    normative: true
    why: 'Provide a durable substrate so semantic state can be anchored, reproduced, and evolved safely.

      '
    what: "Establish the platform foundations as refined milestones under this EP:\n  - Storage spine (SQLite + CAS + seed import)\n  - Snapshot commit pipeline (manifest + ledger anchor)\n"
    how: 'Refinement only. Implementation scenarios live in child Ettles.

      '
- id: ettle:store
  title: Storage Spine (SQLite + CAS + Seed Import)
  eps:
  - id: ep:store:0
    ordinal: 0
    normative: true
    why: 'Snapshot commit is only meaningful if canonical state is durable and content-addressed.

      The storage spine is therefore the immediate prerequisite for snapshot commit and later diff/GC work.

      '
    what: "This Ettle is a structural anchor for the already-implemented Phase 1 Store Spine milestone.\nIt represents the existence of:\n  - SQLite schema + migrations discipline (including facet_snapshots/provenance_events stubs)\n  - Filesystem CAS with atomic writes\n  - cas_blobs index population (non-load-bearing)\n  - Seed Format v0 importer\n\nThe normative implementation detail for this milestone is defined in the bootstrap markdown Ettle\n\u201CPhase 1 Store Spine (SQLite + CAS + Seed Import)\u201D.\n"
    how: "No new implementation scenarios here. The milestone is already delivered.\nThis EP exists to:\n  - provide a stable parent refinement node for snapshot commit,\n  - preserve the dependency relationship in the refinement tree,\n  - and ensure rendered views show correct prerequisites.\n"
  - id: ep:store:1
    ordinal: 1
    normative: true
    why:  '|
      The constraint schema stubs milestone introduces canonical persistence for
      constraints as first-class entities. This requires a stable refinement anchor
      in the storage spine so the dependency relationship is explicit in the tree
      and rendered views show correct prerequisites for snapshot diff and later
      evaluation work. '
    what:  '|
      Structural anchor for the constraint schema stubs milestone under the storage
      spine. Represents the existence of:
        - constraints and ep_constraint_refs tables (additive migrations)
        - family-agnostic manifest constraint envelope
        - cas_blobs and provenance event wiring for constraint objects
  
      The normative implementation detail is defined in the constraint schema stubs
      seed (seed_constraint_schema_stubs_v3.yaml). '
    how:  '|
      No new implementation scenarios here. This EP exists to:
        - provide a stable parent refinement node for ettle:constraint_schema_stubs,
        - preserve the dependency relationship in the refinement tree,
        - and ensure rendered views show constraint stubs as a prerequisite sibling
          to snapshot commit before snapshot diff is implemented. '
- id: ettle:snapshot_commit
  title: Snapshot Commit Pipeline (End-to-End)
  eps:
  - id: ep:snapshot_commit:0
    ordinal: 0
    normative: true
    why: 'Provide immutable semantic anchors by committing canonical state into an append-only ledger.

      Enable reliable reproducible diffs and downstream TES generation by persisting a manifest in CAS and

      anchoring it in the snapshot ledger in a single transaction boundary.


      This is the first point at which the system becomes self-hosting: a stable commit forms a durable

      reference that can be used to reproduce EPT, validate invariants, and generate projections.


      Dependency: this Ettle assumes the Storage Spine exists (SQLite schema + CAS + seed import) and is healthy.

      '
    what: "Implement snapshot commit as a single, atomic operation:\n\n  compute EPT + digests\n    \u2192 build snapshot manifest (structured JSON)\n    \u2192 write manifest to CAS (digest-addressed)\n    \u2192 append ledger entry referencing manifest_digest\n\nPreconditions (normative):\n  - SQLite schema is migrated to head.\n  - facet_snapshots table exists.\n  - CAS store is available and supports atomic writes.\n  - Canonical Ettle/EP state exists and EPT computation is deterministic (Phase 0.5).\n\nThe commit flow MUST be correct under concurrency, MUST be deterministic given identical canonical state,\nMUST be idempotent when re-committing an identical state, and MUST record all required manifest fields.\n\nRequired manifest content (minimum):\n  - manifest_schema_version\n  - created_at (timestamp)\n  - repo/profile/policy references:\n      - policy_ref (string; may be empty but must exist as field)\n      - profile_ref (string; may be empty but must exist as field)\n  - EPT\
      \ ordered list:\n      - ordered ettle_ids\n      - per-ettle ordered EP list (ordinal order) including:\n          - ep_id\n          - ordinal\n          - normative\n          - ep_digest (stable digest of normalized EP payload)\n  - effective constraints / resolution:\n      - effective_constraints (possibly empty list; field MUST exist)\n      - constraint_resolution (possibly empty; field MUST exist)\n  - coverage / exceptions:\n      - coverage (possibly empty; field MUST exist)\n      - exceptions (possibly empty; field MUST exist)\n  - integrity:\n      - root_ettle_id for the commit target\n      - ept_digest (digest of canonical EPT representation)\n      - manifest_digest (CAS digest of manifest bytes; implicit identity; includes created_at)\n      - semantic_manifest_digest (digest of the manifest with created_at excluded; stable comparison key)\n      - store_schema_version (current DB schema version/migration head)\n      - seed_digest (optional; include if available\
      \ from provenance)\n\nLedger append requirements (facet_snapshots table):\n  - snapshot_id (monotonic or UUID; stable identifier)\n  - root_ettle_id\n  - manifest_digest\n  - created_at\n  - parent_snapshot_id (nullable; for linear history; optional in v0 but schema-ready)\n  - status (e.g., committed) if present in schema\n  - any minimal provenance linkage (e.g., provenance_event_id) if present in schema\n\nCAS requirements:\n  - manifest JSON stored as `kind: manifest_json` (or equivalent) and indexed in cas_blobs when healthy.\n  - CAS write MUST be atomic temp\u2192rename.\n  - If the same manifest_digest already exists with identical bytes, treat as success.\n\nTransaction boundary:\n  - The commit operation MUST behave as atomic:\n      - either (a) ledger entry exists AND referenced manifest exists in CAS, or\n      - (b) neither exists (no partial commit).\n  - If CAS write succeeds but ledger append fails, implementation MUST roll back or clean up such that\n    the system\
      \ does not observe a ledger entry pointing at a missing manifest.\n    (A leftover CAS blob without a ledger reference is acceptable but SHOULD be avoided where feasible.)\n\nAPI surface (minimum):\n  - Engine function: `snapshot_commit(root_ettle_id, policy_ref, profile_ref, options) -> snapshot_id`\n  - Options MUST include: expected_head (optional) and dry_run (optional).\n  - Internal CLI wiring MAY be provided as a thin wrapper, but correctness is in the engine.\n\nOut of scope (for this seed):\n  - Snapshot diff algorithm (manifest-to-manifest diff)\n  - Garbage collection / reachability\n  - Full CLI UX beyond invoking commit\n\n\nManifest content requirements (CORE frozen fields + additive envelope):\n  The snapshot manifest MUST contain, at minimum:\n    - schema_version\n    - facet_snapshot_id\n    - realised_ettle_id\n    - ettle_version\n    - created_at                    # included in manifest bytes; digest is non-deterministic by design\n    - approver\n    - policy_ref\n\
      \    - profile_ref\n    - ept                           # ordered EP ids (the committed EPT)\n    - ep_digests                    # map ep_id -> digest (for EPs in ept only)\n    - ept_digest                    # digest of ordered ept structure\n    - constraints                   # family-agnostic envelope (see below)\n    - coverage                      # coverage metrics object\n    - exceptions                    # exception list (may be empty)\n    - manifest_digest               # digest over the exact manifest bytes written to CAS\n    - semantic_manifest_digest      # digest over a canonicalised copy of the manifest with created_at removed/zeroed\n\n  Constraints envelope (anti-lock-in contract):\n    - The manifest MUST contain a top-level `constraints` object that is extensible by family.\n    - The `constraints` object MUST be shaped so that ABB\u2192SBB is represented as ONE family, not the whole schema.\n    - However, to remain compatible with the CORE charter and existing\
      \ tooling, the `constraints` object MUST also\n      expose the CORE frozen ABB/SBB projections as stable fields.\n\n  Required shape (minimum viable, additive-safe):\n    constraints:\n      declared_refs: []             # ordered, deterministic list of constraint refs active on the EPT (may be empty)\n      families: {}                  # map family_name -> {active_refs, outcomes, evidence, digest} (may be empty)\n      # Frozen ABB\u2192SBB projections (must exist even if empty):\n      applicable_abb: []            # list of ABB constraint ids\n      resolved_sbb: []              # list of resolved SBB constraint ids\n      resolution_evidence: []       # opaque evidence records (predicate matched, selected ids, etc.)\n      constraints_digest: <digest>  # digest over canonicalised constraints envelope (NOT including created_at)\n\n  Determinism rules (binding):\n    - `ept` order MUST be deterministic (by EPT computation rules).\n    - `declared_refs` order MUST be deterministic:\n\
      \        - primary: family then kind then id (lexicographic), unless an explicit ordinal is stored.\n    - `families` keys MUST be ordered deterministically in canonicalisation (lexicographic).\n    - Any list inside `families[family].*` MUST be deterministically ordered.\n"
    how: "Implementation approach (normative):\n  - Deterministic traversal:\n      - EPT computation MUST use deterministic ordering primitives (no hash-iteration dependence).\n      - EP ordering per Ettle MUST be ordinal order.\n  - Digesting:\n      - EP digest MUST be computed from a canonical serialization of normalized EP content.\n      - EPT digest MUST be computed from a canonical serialization of the ordered EPT structure.\n      - Manifest digest MUST be computed over exact manifest JSON bytes written to CAS.\n  - Manifest serialization:\n      - MUST be stable JSON with deterministic key ordering and deterministic list ordering.\n      - The manifest MUST include `created_at` in the manifest JSON bytes written to CAS.\n      - As a result, `manifest_digest` is expected to vary between commits even when canonical state is unchanged.\n      - The system MUST therefore compute and record `semantic_manifest_digest` as the stable comparison key:\n          - `semantic_manifest_digest`\
      \ is computed over a canonical serialization of the manifest with `created_at` excluded.\n          - All idempotency/determinism comparisons for \u201Csame canonical state\u201D MUST use `semantic_manifest_digest`\n            (and `ept_digest`), not `manifest_digest`.\n      - The manifest MUST record both:\n          - `manifest_digest` (CAS digest of full bytes, including created_at)\n          - `semantic_manifest_digest` (comparison key excluding created_at)\n      - This rule MUST be documented and tested.\nScenarios (all MUST be implemented as tests; unit/integration; Gherkin is normative):\n\nFeature: Snapshot commit pipeline\n\n  Background:\n    Given a repository with SQLite + CAS store initialised\n    And canonical Ettle/EP state exists in SQLite\n    And the EPT computation is deterministic and tested (Phase 0.5)\n\n  # --- Happy path and core invariants ---\n\n  Scenario: Commit writes manifest to CAS and appends ledger entry in one logical commit\n    Given root_ettle_id\
      \ \"ettle:root\" exists\n    And policy_ref is \"policy/default@0\"\n    And profile_ref is \"profile/default@0\"\n    When I call snapshot_commit for \"ettle:root\"\n    Then a manifest JSON blob is written to CAS\n    And the CAS blob digest equals manifest_digest recorded in the ledger\n    And a facet_snapshots ledger row exists referencing that manifest_digest\n    And the manifest contains an EPT ordered list\n    And every EP in the manifest has a stable ep_digest\n    And effective_constraints, constraint_resolution, coverage, and exceptions fields exist (even if empty)\n\n  Scenario: Commit is deterministic for identical canonical state\n    Given the canonical DB state is unchanged between runs\n    When I call snapshot_commit twice (without modifying canonical state)\n    Then the produced manifest is semantically identical between the two commits\n    And the EPT digest is identical\n    And semantic_manifest_digest is identical between the two commits\n    And manifest_digest\
      \ differs between the two commits (created_at varies)\n\n  Scenario: Manifest includes created_at and semantic_manifest_digest\n    When I call snapshot_commit\n    Then the manifest includes created_at\n    And the manifest includes semantic_manifest_digest\n    And semantic_manifest_digest is computed with created_at excluded\n\n  Scenario: Commit records policy_ref and profile_ref exactly as provided\n    Given policy_ref is \"policy/foo@1.2\"\n    And profile_ref is \"profile/bar@0.9\"\n    When I call snapshot_commit\n    Then the manifest policy_ref equals \"policy/foo@1.2\"\n    And the manifest profile_ref equals \"profile/bar@0.9\"\n\n  Scenario: Commit enforces referential integrity between ledger and CAS\n    When snapshot_commit succeeds\n    Then reading CAS at manifest_digest returns valid JSON\n    And parsing that JSON yields manifest_schema_version and required fields\n    And loading the ledger row and following manifest_digest always resolves\n\n  # --- Idempotency\
      \ and duplicates ---\n\n  Scenario: Commit rejects duplicate ledger entry for same parent head when expected_head is supplied\n    Given the repository head snapshot_id is H\n    When I call snapshot_commit with expected_head = H\n    And the commit succeeds producing new snapshot_id H2\n    When I call snapshot_commit again with expected_head = H\n    Then the commit fails with HeadMismatch\n    And no new ledger row is appended\n\n  Scenario: Commit is safe when called concurrently with the same expected_head\n    Given two workers A and B with expected_head = H\n    When both call snapshot_commit concurrently\n    Then exactly one commit succeeds\n    And the other fails with HeadMismatch (or equivalent optimistic concurrency error)\n    And the ledger remains a linear history (no duplicate head)\n\n  # --- Boundary conditions ---\n\n  Scenario: Commit with a single Ettle and a single EP\n    Given a root tree containing exactly 1 ettle with exactly 1 EP\n    When snapshot_commit\
      \ runs\n    Then manifest EPT contains exactly one ettle_id\n    And that ettle has exactly one EP entry with ordinal 0\n\n  Scenario: Commit with a large but valid EPT (stress)\n    Given a generated canonical state with N=1000 ettles and M=5000 EPs\n    When snapshot_commit runs\n    Then it completes successfully within a reasonable bound for local execution\n    And manifest size_bytes is recorded in cas_blobs\n    And no ordering instability occurs (EPT digest stable across two runs)\n\n  Scenario: Commit when effective_constraints is empty\n    Given no constraints exist in canonical state\n    When snapshot_commit runs\n    Then manifest effective_constraints is an empty list\n    And manifest constraint_resolution is present and empty (object or list per schema)\n\n  Scenario: Commit when coverage/exceptions are empty\n    Given no coverage data exists\n    And no exceptions exist\n    When snapshot_commit runs\n    Then manifest coverage is present and empty\n    And manifest\
      \ exceptions is present and empty\n\n  # --- Negative cases: invalid inputs and missing state ---\n\n  Scenario: Commit fails when root_ettle_id does not exist\n    Given root_ettle_id \"ettle:missing\" does not exist\n    When I call snapshot_commit for \"ettle:missing\"\n    Then the call fails with NotFound\n    And no CAS manifest is written\n    And no ledger row is appended\n\n  Scenario: Commit fails when canonical state violates EPT invariants\n    Given the canonical state contains a cycle in refinement links\n    When snapshot_commit runs\n    Then it fails with CycleDetected (or equivalent)\n    And no ledger row is appended\n\n  Scenario: Commit fails when EP ordinals are non-unique within an ettle\n    Given an ettle with duplicate ordinal EP entries exists in SQLite\n    When snapshot_commit runs\n    Then it fails with OrdinalConflict\n    And no ledger row is appended\n\n  Scenario: Commit fails when an EP references missing CAS content (if EP payload is CAS-backed)\n\
      \    Given an EP row references ep_body_digest D\n    And CAS does not contain D\n    When snapshot_commit runs\n    Then it fails with CasMissing\n    And no ledger row is appended\n\n  # --- Negative cases: CAS and DB failure injection ---\n\n  Scenario: CAS write failure prevents ledger append\n    Given CAS is configured to fail writes (simulated IO error)\n    When snapshot_commit runs\n    Then it fails with CasWriteFailed\n    And no ledger row is appended\n\n  Scenario: Ledger append failure does not produce a visible partial commit\n    Given CAS writes succeed\n    And SQLite is configured to fail during facet_snapshots insert (simulated)\n    When snapshot_commit runs\n    Then it fails with LedgerAppendFailed\n    And no new facet_snapshots row exists\n    And the head snapshot_id is unchanged\n    And (optional) the manifest blob may exist in CAS but is not referenced\n\n  Scenario: Transaction rollback leaves no partial DB changes\n    Given snapshot_commit is interrupted\
      \ mid-transaction (simulated)\n    When the process restarts\n    Then the database contains no partially written snapshot rows for the interrupted commit\n    And schema invariants remain intact\n\n  # --- Consistency checks for manifest content ---\n\n  Scenario: Manifest EPT is ordered and stable\n    When snapshot_commit runs\n    Then the manifest EPT list is ordered deterministically\n    And EPT ordering is identical to Phase 0.5 traversal output\n\n  Scenario: Every EP entry in the manifest includes required fields\n    When snapshot_commit runs\n    Then for each EP entry:\n      And ep_id is present\n      And ordinal is present\n      And normative is present\n      And ep_digest is present\n\n  Scenario: Manifest includes store_schema_version and optional seed_digest\n    Given the store has applied migration head \"0007\" (example)\n    And provenance contains a seed_digest from the last seed import\n    When snapshot_commit runs\n    Then manifest store_schema_version\
      \ equals the current migration head\n    And manifest seed_digest equals the provenance seed_digest\n\n  # --- Dry run behaviour ---\n\n  Scenario: Dry-run computes manifest but does not persist\n    Given options.dry_run is true\n    When snapshot_commit runs\n    Then it returns a computed manifest (or digest) in the response\n    And no CAS blob is written\n    And no ledger row is appended\n\n  # --- Reproducibility across reload ---\n\n  Scenario: Commit after DB reload produces stable digests\n    Given a canonical state was imported and committed once\n    And the process is restarted\n    And the canonical state is reloaded from SQLite\n    When snapshot_commit runs again without changes\n    Then EPT digest is identical to the prior run\n    And EP digests are identical to the prior run\n\n\nAdditional scenarios (constraints envelope + future-proofing):\n\n  Scenario: Snapshot manifest always contains constraints envelope fields even when no constraints are attached\n    Given\
      \ an EPT whose EPs have no attached constraints\n    When I run snapshot_commit with a selected leaf EP\n    Then the manifest contains constraints.declared_refs as an empty list\n    And the manifest contains constraints.families as an empty map\n    And the manifest contains constraints.applicable_abb as an empty list\n    And the manifest contains constraints.resolved_sbb as an empty list\n    And the manifest contains constraints.resolution_evidence as an empty list\n\n  Scenario: Deterministic ordering of declared_refs is stable across insertion order\n    Given EP A and EP B each attach constraints in different insertion orders\n    And both constraints are active on the committed EPT\n    When I snapshot_commit twice with identical canonical state except insertion order\n    Then constraints.declared_refs ordering is identical\n    And constraints_digest is identical\n    And semantic_manifest_digest is identical\n\n  Scenario: Unknown constraint families are preserved as opaque\
      \ outcomes without breaking snapshot commit\n    Given a constraint with family \"observability\" is attached to an EP\n    And no evaluation/resolution engine exists for that family (stub phase)\n    When I snapshot_commit\n    Then constraints.declared_refs includes that constraint id\n    And constraints.families may include an entry for \"observability\" with an empty outcomes list\n    And snapshot commit succeeds without attempting to interpret the family payload\n\n  Scenario: Snapshot commit rejects non-deterministic family outcome ordering\n    Given a constraints.families entry is produced from a HashMap iteration order\n    When I attempt to commit a snapshot\n    Then the system detects ordering non-determinism under determinism checks\n    And snapshot commit fails with DeterminismViolation (unless waived by policy)\n"
links:
- parent: ettle:root
  parent_ep: ep:root:1
  child: ettle:store
- parent: ettle:store
  parent_ep: ep:store:0
  child: ettle:snapshot_commit

