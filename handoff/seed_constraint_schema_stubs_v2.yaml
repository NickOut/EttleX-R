schema_version: 0
project:
  name: ettlex
ettles:
- id: ettle:constraint_schema_stubs
  title: Constraint Schema Stubs (CORE spine extensibility contract)
  eps:
  - id: ep:constraint_schema_stubs:0
    ordinal: 0
    normative: true
    why: 'Snapshot diff and later evaluation work depend on being able to persist, reference, and transport constraints

      without prematurely locking the system into a single constraint family (e.g., ABB/SBB).


      CORE requires that the snapshot manifest contains effective ABB constraints and resolved SBB selections,

      but MEDIUM explicitly generalises constraints into multiple families. This seed introduces the minimal

      persistence and manifest-envelope stubs needed so later work (diff, evaluation, resolution, bytecode)

      can evolve without schema churn or ABI breakage.


      This seed is intentionally non-load-bearing: it adds schema and manifest envelope capabilities only.

      '
    what: "Implement the minimal canonical persistence and manifest-schema extensions needed before snapshot diff.\n\nSuccess criteria (binding):\n  1) Constraint entities exist in canonical state, with EP-level attachment.\n  2) EP reference tables exist such that a closure (EPT) can enumerate which constraints were\n     declared/attached along that closure.\n  3) Snapshot manifest includes a constraint envelope that is family-agnostic.\n  4) Nothing in canonical state, snapshot commit, or later seeds is constrained to ABB/SBB-only.\n  5) The implementation does not introduce evaluation, resolution, or enforcement logic.\n\nDependency assumptions (pre-existing):\n  - Storage spine exists (SQLite + CAS + migrations discipline).\n  - Snapshot commit exists (manifest written to CAS; ledger append).\n\n---\nNormative CORE spine constraint extensibility contract\n\nThe implementation MUST satisfy the frozen CORE invariants while remaining compatible with MEDIUM/FUTURE.\n\nA) Frozen CORE requirements\
      \ that MUST remain true (until v0.3):\n\n  A.1 Manifest required fields and additive-only evolution\n      - \"Snapshot manifest SHALL contain: ... effective ABB constraints ... resolved SBB selections ...\"\n        and \"Manifest schema may only be extended (additive changes allowed). Field removals are prohibited.\"\n\n  A.2 Constraint DSL complexity is explicitly experimental but MUST NOT alter frozen core invariants.\n\nB) MEDIUM constraint-family generalisation that MUST be supported by CORE implementations:\n\n  B.1 \"ABB\u2192SBB is one family. MEDIUM introduces a generalized constraint taxonomy\" including multiple\n      families beyond pattern constraints.\n\n  B.2 Each constraint has (minimum) identifiers and classification: constraint_id, family, kind, scope,\n      plus predicate/effects/evidence requirements.\n\nC) FUTURE stability rules that MUST remain possible:\n\n  C.1 \"No FUTURE feature may redefine CORE invariants. FUTURE features must be optional and must\n \
      \     degrade safely to MEDIUM behaviour under conservative policies/profiles.\"\n\n  C.2 FUTURE event sources include \"constraint edits\" and automation must be policy/profile governed.\n\nD) Contract rules (binding; these are the guardrails that prevent ABB/SBB lock-in):\n\n  D.1 Family-agnostic canonical representation\n      - Canonical state MUST represent constraints as first-class entities with a `family` field.\n      - Canonical state MUST NOT hard-code a closed set of families.\n      - Canonical state MUST treat ABB/SBB (if present) as one possible family, not the schema.\n\n  D.2 Family-agnostic manifest envelope\n      - The snapshot manifest MUST contain a `constraints` envelope that can carry constraints from\n        any family.\n      - The envelope MUST be structured such that unknown families can be preserved and diffed as\n        opaque payloads (by digest) without being interpreted.\n\n  D.3 CORE-required ABB/SBB fields as a *projection*\n      - To satisfy CORE\
      \ manifest requirements, the manifest MUST include the CORE-required ABB/SBB\n        fields.\n      - Those ABB/SBB fields MUST be derived from (or be aliases of) the family-agnostic envelope, not\n        be the sole representation.\n      - If no ABB/SBB constraints exist, the ABB/SBB fields MUST still exist and MUST represent an empty\n        effective/resolved set.\n\n  D.4 Additive-only, schema-stable evolution\n      - All new manifest fields introduced by this seed MUST be additive.\n      - All new database tables/columns introduced by this seed MUST be additive.\n      - Existing snapshot commit behaviour MUST remain valid, except for adding new fields that must\n        be populated deterministically.\n\n  D.5 No evaluation/resolution semantics in this seed\n      - This seed MUST NOT introduce a constraint evaluation engine.\n      - This seed MUST NOT implement ABB/SBB resolution logic.\n      - This seed MUST NOT block snapshot commits due to constraint content.\n\n\
      \  D.6 Determinism requirements for later diff/commit\n      - Any ordering applied to constraint lists in manifests MUST be deterministic.\n      - Any digest computed over constraint payloads MUST be based on canonical serialization.\n\n---\nRequired schema changes (minimum; additive):\n\n  1) constraints\n      - constraint_id (string; stable; opaque)\n      - family (string; open set)\n      - kind (string; open set)\n      - scope (string; open set)\n      - payload_json (json/text; opaque family payload; may be minimal in CORE)\n      - created_at, updated_at\n      - deleted (tombstone)\n\n  2) ep_constraints (EP attachment)\n      - ep_id\n      - constraint_id\n      - ordinal (int; deterministic ordering within an EP; immutable once assigned)\n      - strength (string; optional stub; keep as text)\n      - created_at\n      - deleted (tombstone)\n\n  3) (optional but recommended stub) constraint_refs (snapshot-time reference index)\n      - snapshot_id\n      - constraint_id\n\
      \      - role (declared/effective/resolved/evidence)\n\nRequired snapshot manifest fields (minimum; additive; deterministic):\n\n  - constraints:\n      - schema_version (int)\n      - declared: [ {constraint_id, family, kind, scope, payload_digest} ... ]\n      - effective: [ {constraint_id, family, kind, scope, payload_digest} ... ]\n      - resolved: [ {constraint_id, family, kind, scope, resolution_digest?} ... ]\n      - evidence: [ {constraint_id, evidence_digest} ... ]\n\n  - effective_abb_constraints: []\n  - resolved_sbb_selections: []\n  - resolution_evidence: []\n\nNotes (binding):\n  - In CORE, declared/effective/resolved may all be identical for now (no evaluation).\n  - payload_digest MUST be present even if payload_json is empty: the digest commits the payload bytes.\n  - Unknown families MUST be preserved in payload_json and represented in manifest.\n\n\nCanonical schema extensions (SQLite; additive-only):\n\n  The store MUST introduce the following canonical tables\
      \ (names are binding for v0.1/v0.2 unless already present):\n\n    1) constraints\n       - constraint_id TEXT PRIMARY KEY\n       - family TEXT NOT NULL                        # anti-lock-in: required for all constraints\n       - kind TEXT NOT NULL                          # 'abb' | 'sbb' | 'other' (stringly typed in stub phase)\n       - payload_json TEXT NULL                      # opaque JSON (family-defined schema; not interpreted here)\n       - payload_digest TEXT NULL                    # sha256 of canonical JSON bytes when payload_json present\n       - created_at TEXT NOT NULL\n       - updated_at TEXT NOT NULL\n       - deleted_at TEXT NULL                        # tombstone (optional but recommended)\n\n    2) ep_constraint_refs\n       - ep_id TEXT NOT NULL\n       - constraint_id TEXT NOT NULL\n       - ordinal INTEGER NOT NULL DEFAULT 0          # deterministic ordering surface (0 when unused)\n       - created_at TEXT NOT NULL\n       PRIMARY KEY (ep_id, constraint_id)\n\
      \       FOREIGN KEY(ep_id) REFERENCES eps(ep_id)\n       FOREIGN KEY(constraint_id) REFERENCES constraints(constraint_id)\n\n    3) constraint_sets (OPTIONAL in v0.1; RECOMMENDED as a stub anchor for MEDIUM)\n       - constraint_set_id TEXT PRIMARY KEY\n       - name TEXT NOT NULL\n       - family_hint TEXT NULL\n       - payload_json TEXT NULL\n       - created_at TEXT NOT NULL\n       - updated_at TEXT NOT NULL\n\n    4) constraint_set_members (OPTIONAL if constraint_sets exists)\n       - constraint_set_id TEXT NOT NULL\n       - constraint_id TEXT NOT NULL\n       - ordinal INTEGER NOT NULL DEFAULT 0\n       PRIMARY KEY (constraint_set_id, constraint_id)\n\n  Notes:\n    - No evaluator is implemented in this seed: payload_json is opaque.\n    - Determinism is enforced by explicit `ordinal` fields or lexicographic ordering fallbacks.\n    - These tables MUST NOT force ABB/SBB-specific columns beyond the generic (family, kind, payload).\n\nAPI surface (Rust store/core; minimal):\n\
      \  - create_constraint(family, kind, payload_json?) -> constraint_id\n  - get_constraint(constraint_id) -> constraint record\n  - attach_constraint(ep_id, constraint_id, ordinal?) -> ()\n  - detach_constraint(ep_id, constraint_id) -> ()\n  - list_constraints_for_ep(ep_id) -> ordered list\n"
    how: "Scenarios (all MUST be implemented as tests; unit/integration; Gherkin is normative):\n\nFeature: Constraint schema stubs and extensibility contract\n\n  Background:\n    Given a repository with SQLite + CAS store initialised\n    And snapshot commit is already implemented and passing tests\n\n  # --- Schema and persistence stubs ---\n\n  Scenario: Create a constraint entity with an arbitrary family without code changes\n    Given a constraint payload JSON with family \"platform\" and kind \"runtime\"\n    When I create a constraint with family \"platform\" and kind \"runtime\"\n    Then it is stored in canonical state with family \"platform\" preserved verbatim\n    And no validation rejects unknown families\n\n  Scenario: Attach multiple constraints to a single EP with stable ordering\n    Given an EP \"ep:example:0\" exists\n    And two constraints exist \"c:1\" and \"c:2\"\n    When I attach \"c:1\" with ordinal 0 and \"c:2\" with ordinal 1\n    Then listing EP constraints\
      \ returns [\"c:1\", \"c:2\"] in ordinal order\n    And ordinals are immutable (attempt to reassign fails)\n\n  Scenario: Tombstoning a constraint does not delete historical attachment records\n    Given constraint \"c:3\" is attached to EP \"ep:example:0\"\n    When I tombstone constraint \"c:3\"\n    Then the constraint is excluded from active queries\n    But historical snapshots that referenced \"c:3\" remain readable\n\n  # --- Manifest envelope requirements ---\n\n  Scenario: Snapshot commit includes a family-agnostic constraints envelope\n    Given root_ettle_id \"ettle:root\" exists\n    And the EPT includes an EP with attached constraints of families \"pattern\" and \"compliance\"\n    When I call snapshot_commit for \"ettle:root\"\n    Then the manifest contains a top-level \"constraints\" envelope\n    And the envelope contains entries for both families\n    And each entry includes constraint_id, family, kind, scope, and payload_digest\n    And the ordering of constraints\
      \ in each list is deterministic\n\n  Scenario: CORE-required ABB/SBB manifest fields remain present as projection\n    Given the current closure includes zero ABB/SBB-family constraints\n    When I call snapshot_commit\n    Then manifest fields effective_abb_constraints, resolved_sbb_selections, and resolution_evidence exist\n    And each of those fields is an empty list\n    And the family-agnostic constraints envelope still exists and is authoritative\n\n  Scenario: Unknown constraint families are preserved without interpretation\n    Given a constraint with family \"vendor_ext\" and payload containing unknown fields\n    When I call snapshot_commit\n    Then the manifest includes that constraint in the constraints envelope\n    And payload_digest matches a canonical digest of payload_json\n    And no code path attempts to interpret the payload structure\n\n  # --- Negative cases and invariants ---\n\n  Scenario: Attempting to constrain families to an enum is rejected by contract\
      \ tests\n    Given code changes that introduce a closed enum of constraint families\n    When contract tests are run\n    Then they fail with a message \"constraint family MUST be open set\"\n\n  Scenario: Manifest field removal is prohibited\n    Given code changes that remove \"effective_abb_constraints\" or \"constraints\" from the manifest\n    When snapshot commit tests are run\n    Then they fail with a message \"Manifest schema may only be extended\"\n\n  Scenario: Non-deterministic constraint ordering is detected\n    Given code changes that iterate constraints using hash-map iteration order\n    When I call snapshot_commit twice with identical canonical state\n    Then semantic_manifest_digest differs\n    And the failure is reported as DeterminismViolation\n\n  Scenario: Snapshot commit does not fail due to constraint content\n    Given a constraint payload that is syntactically malformed for its family\n    When I attach it to an EP and call snapshot_commit\n    Then the\
      \ commit succeeds\n    And the payload is preserved as opaque bytes with a payload_digest\n\n  # --- Boundary conditions ---\n\n  Scenario: Large constraint payloads are supported as opaque blobs\n    Given a constraint payload of size 1MB\n    When I store it and commit a snapshot\n    Then payload_digest is computed successfully\n    And the manifest size is within configured CAS limits\n\n  Scenario: Constraint attachment list can be empty\n    Given an EP with no attached constraints\n    When I call snapshot_commit\n    Then constraints.declared may be empty\n    And the manifest still contains the constraints envelope and ABB/SBB projection fields\n"
links:
- parent: ettle:store
  parent_ep: ep:store:0
  child: ettle:constraint_schema_stubs
- parent: ettle:constraint_schema_stubs
  parent_ep: ep:constraint_schema_stubs:0
  child: ettle:snapshot_diff
