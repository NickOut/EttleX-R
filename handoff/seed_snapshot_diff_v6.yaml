schema_version: 0
project:
  name: ettlex
ettles:
- id: ettle:snapshot_diff
  title: Snapshot Diff Engine (manifest-to-manifest diff; decision-isolated)
  eps:
  - id: ep:snapshot_diff:0
    ordinal: 0
    normative: true
    why: "A snapshot is a semantic anchor: it captures one closure (one EPT) as committed manifest bytes.\nTo evolve safely, the system must be able to compute an explicit, deterministic difference between\ntwo snapshots.\n\nA manifest-to-manifest diff engine provides:\n  - human-readable semantic change summaries for review and approval,\n  - machine-readable change sets to drive CIA-style impact reporting,\n  - deterministic evidence for whether an edit is a refactor vs a semantic modification,\n  - the foundation for later reachability, compatibility, and drift evaluators.\n\nThis engine must treat the manifest as the source of truth for a committed closure, and it must\nremain robust as the manifest evolves additively.\n"
    what: "Implement a deterministic diff engine that compares two snapshot manifests and produces:\n  1) A structured diff (JSON) suitable for downstream evaluators.\n  2) A human-readable summary (Markdown/text) for review.\n\nInputs (minimum):\n  - manifest_a (bytes or parsed representation)\n  - manifest_b (bytes or parsed representation)\n\nOutput (minimum):\n  - diff schema version\n  - identity:\n      - a.manifest_digest, a.semantic_manifest_digest, a.ept_digest\n      - b.manifest_digest, b.semantic_manifest_digest, b.ept_digest\n  - change categories:\n      - ept_changes\n      - ep_content_changes\n      - constraint_changes (family-agnostic)\n      - coverage_changes\n      - exception_changes\n      - metadata_changes (policy_ref, profile_ref, store_schema_version, etc.)\n  - severity classification per change (none / informational / semantic / breaking)\n\nRequired properties (binding):\n  - Determinism: identical inputs produce byte-identical structured diff output.\n  -\
      \ Created-at noise suppression: created_at differences MUST NOT be treated as semantic changes.\n  - Additive manifest compatibility: unknown future manifest fields MUST be ignored by default\n    (reported as \"unknown_changes\" only when they change).\n  - Constraint-family agnosticism: diff MUST operate over the constraints envelope without\n    requiring knowledge of specific families.\n\nInterface exposure (binding):\n  - The diff computation is a read-only query over committed manifests.\n  - Implementations MUST expose an action:query surface (or equivalent) callable by MCP/CLI:\n      - snapshot.diff(a_ref, b_ref) -> { structured_diff_json, human_summary }\n    where a_ref/b_ref are snapshot_id or manifest_digest (and MUST resolve to manifest bytes).\n  - The diff operation MUST NOT mutate canonical state, CAS, or ledger.\n  - The diff operation MUST NOT read canonical DB state for semantic comparison; it MUST operate\n    exclusively on manifest bytes (plus their recorded digests).\n  - MCP (when present) MUST be a thin transport wrapper over the same action:query surface.\n\n\nDependency assumptions (pre-existing):\n  - snapshot_commit writes manifests to CAS and records manifest_digest + semantic_manifest_digest.\n  - constraint schema stubs exist and manifests contain a family-agnostic constraints envelope.\n\nOut of scope (for this seed):\n  - Computing diffs directly from canonical state (DB)\n  - Merge/conflict resolution\n  - Automated gate decisions (policy/profile enforcement)\n\n\nConstraint diff contract (family-agnostic, CORE-compatible):\n\n  The diff engine MUST treat the manifest as the canonical semantic boundary.\n  It MUST NOT traverse or diff the Ettle\
      \ tree.\n\n  `constraint_changes` MUST be computed from the manifest constraints envelope as follows:\n    - declared_ref_changes: additions/removals of constraints.declared_refs (set delta, plus ordered view)\n    - family_changes:\n        - per-family digest change if constraints.families[family].digest changes\n        - per-family outcome deltas if the family section is parseable (otherwise opaque-bytes diff)\n    - abb_sbb_projection_changes:\n        - additions/removals in constraints.applicable_abb and constraints.resolved_sbb\n        - evidence changes in constraints.resolution_evidence (byte-level or canonicalised-object diff)\n    - constraints_digest_change: compare constraints.constraints_digest\n\n  The diff output MUST remain stable under additive manifest evolution:\n    - unknown fields are ignored or surfaced under metadata_changes, but MUST NOT break diffing.\n    - unknown constraint families are diffed opaquely via their family digest and presence.\n"
    how: "Scenarios (all MUST be implemented as tests; unit/integration; Gherkin is normative):\n\nFeature: Snapshot diff engine\n\n  Background:\n    Given a repository with SQLite + CAS store initialised\n    And at least two committed snapshots exist with their manifests available\n\n  # --- Identity and determinism ---\n\n  Scenario: Diff output is deterministic\n    Given manifest A bytes and manifest B bytes are fixed\n    When I compute diff(A,B) twice\n    Then the structured diff JSON bytes are identical\n    And the human summary is identical\n\n  Scenario: Diffing a manifest against itself yields no changes (degenerate fast-path)\n    Given manifest A is loaded once into memory\n    When I compute diff(A,A)\n    Then the diff severity is none\n    And ept_changes is empty\n    And ep_content_changes is empty\n    And constraint_changes is empty\n    And coverage_changes is empty\n    And exception_changes is empty\n    And metadata_changes is empty\n    And unknown_changes is empty\n    And the implementation MAY short-circuit by comparing semantic_manifest_digest\n\n  Scenario: Diff treats created_at as non-semantic\n    Given manifest A and manifest B differ only in created_at and manifest_digest\n    And semantic_manifest_digest is identical\n    When I compute diff(A,B)\n    Then the diff classification is \"no_semantic_change\"\n    And ept_changes is empty\n    And ep_content_changes is empty\n    And constraint_changes is empty\n\n  Scenario: Diff detects manifest evolution without breaking\n\
      \    Given manifest B contains additional unknown top-level fields not present in manifest A\n    When I compute diff(A,B)\n    Then the diff includes an \"unknown_changes\" section\n    And all known change categories are still computed correctly\n    And the diff does not fail\n\n  # --- EPT-level change detection ---\n\n  Scenario: Diff detects EPT change (closure changed)\n    Given manifest A has ept_digest \"ept:1\" and manifest B has ept_digest \"ept:2\"\n    When I compute diff(A,B)\n    Then ept_changes indicates \"changed\"\n    And severity is at least \"semantic\"\n    And the human summary lists added/removed/moved EP references\n\n  Scenario: Diff detects EP digest changes within same EPT structure\n    Given manifest A and B have identical EPT structure (same ordered EP ids)\n    But one EP digest differs\n    When I compute diff(A,B)\n    Then ep_content_changes lists that EP id\n    And severity is \"semantic\"\n\n  Scenario: Diff detects ordinal reordering as EPT\
      \ change\n    Given manifest B reorders EPs within an Ettle without changing EP content\n    When I compute diff(A,B)\n    Then ept_changes is non-empty\n    And the summary calls out an ordering change\n\n  # --- Constraint diffs (family-agnostic) ---\n\n  Scenario: Diff detects addition of a constraint of unknown family\n    Given manifest A constraints.declared is empty\n    And manifest B constraints.declared includes constraint_id \"c:vendor\" family \"vendor_ext\"\n    When I compute diff(A,B)\n    Then constraint_changes.declared.added contains \"c:vendor\"\n    And the diff does not attempt to interpret the payload\n    And severity is \"semantic\" unless profile marks it informational\n\n  Scenario: Diff detects change in constraint payload via digest\n    Given manifest A contains constraint \"c:1\" with payload_digest \"d1\"\n    And manifest B contains constraint \"c:1\" with payload_digest \"d2\"\n    When I compute diff(A,B)\n    Then constraint_changes.payload_changed\
      \ contains \"c:1\"\n    And the human summary shows \"constraint payload changed\" without parsing family content\n\n  Scenario: Diff maintains CORE ABB/SBB projection parity\n    Given manifests include both the family-agnostic constraints envelope\n    And the CORE ABB/SBB projection fields\n    When I compute diff(A,B)\n    Then constraint_changes are computed from the constraints envelope\n    And ABB/SBB fields are treated as redundant projections\n    And if ABB/SBB fields disagree with the envelope, the diff reports InvariantViolation\n\n  # --- Coverage and exceptions ---\n\n  Scenario: Diff detects coverage metric changes\n    Given manifest A coverage differs from manifest B coverage\n    When I compute diff(A,B)\n    Then coverage_changes is populated\n    And severity is \"informational\" unless policy marks it gating\n\n  Scenario: Diff detects exception list changes\n    Given manifest A exceptions is empty\n    And manifest B exceptions contains one exception\n    When\
      \ I compute diff(A,B)\n    Then exception_changes.added contains that exception\n    And severity is at least \"semantic\"\n\n  # --- Metadata and governance references ---\n\n  Scenario: Diff detects policy_ref/profile_ref changes\n    Given manifest A policy_ref is \"policy/x@1\" and manifest B policy_ref is \"policy/y@1\"\n    When I compute diff(A,B)\n    Then metadata_changes includes policy_ref\n    And severity is \"informational\" unless policy requires re-approval\n\n  Scenario: Diff detects store schema version change\n    Given manifest A store_schema_version differs from manifest B store_schema_version\n    When I compute diff(A,B)\n    Then metadata_changes includes store_schema_version\n    And severity is \"informational\"\n\n  # --- Negative cases ---\n\n  Scenario: Diff rejects invalid manifest schema_version\n    Given manifest A has schema_version \"not-an-int\"\n    When I compute diff(A,B)\n    Then a typed error InvalidManifest is returned\n\n  Scenario: Diff\
      \ rejects non-canonical JSON ordering in structured diff output\n    Given code changes that emit structured diff with non-deterministic key order\n    When I compute diff(A,B) twice\n    Then the determinism test fails\n    And the failure is reported as DeterminismViolation\n\n  Scenario: Diff fails fast on missing required digests\n    Given manifest A is missing semantic_manifest_digest\n    When I compute diff(A,B)\n    Then a typed error MissingField is returned\n\n  # --- Boundary conditions ---\n\n  Scenario: Diff handles large manifests efficiently\n    Given manifest A and B are each 5MB\n    When I compute diff(A,B)\n    Then diff completes within configured time budget\n    And peak memory usage remains within configured limits\n\n  Scenario: Diff handles identical manifests by returning a minimal diff\n    Given manifest A and manifest B are byte-identical\n    When I compute diff(A,B)\n    Then diff classification is \"identical\"\n    And all change categories are empty\n\
      \n\nAdditional scenarios (constraints envelope + negative cases):\n\n  Scenario: Diff detects constraint reference additions/removals even when ABB/SBB projections are empty\n    Given manifest A constraints.declared_refs is empty\n    And manifest B constraints.declared_refs contains constraint/c1\n    And both manifests have empty applicable_abb/resolved_sbb\n    When I compute diff(A,B)\n    Then constraint_changes.declared_ref_changes.added contains constraint/c1\n    And constraint_changes.abb_sbb_projection_changes is empty\n    And overall severity is at least \"semantic\" (not \"telemetry-only\")\n\n  Scenario: Diff treats unknown constraint family outcomes as opaque and stable\n    Given manifest A has constraints.families[\"observability\"].digest = D1\n    And manifest B has constraints.families[\"observability\"].digest = D2\n    And the diff engine does not understand \"observability\"\n    When I compute diff(A,B)\n    Then constraint_changes.family_changes[\"observability\"\
      ].digest_changed is true\n    And no parsing error occurs\n\n  Scenario: Diff ignores additive unknown manifest fields while still computing known category diffs\n    Given manifest B includes a new top-level field \"new_field_x\" not present in manifest A\n    When I compute diff(A,B)\n    Then diff computation succeeds\n    And metadata_changes includes \"new_field_x\"\n    And category diffs (ept/ep/constraints/coverage/exceptions) are still correct\n\n\nAdditional scenarios (action:query surface + reference resolution + invariants):\n\n  Scenario: Diff is exposed via action:query and is read-only\n    Given two committed snapshots S1 and S2 exist\n    And the provenance ledger has N entries\n    When I call snapshot.diff(S1,S2) via the action:query surface\n    Then the call succeeds\n    And the provenance ledger still has N entries\n    And no CAS blobs are written\n\n  Scenario: Diff resolves snapshot_id references to manifest bytes deterministically\n    Given snapshot_id S1 resolves to manifest_digest D1\n    And snapshot_id S2 resolves to manifest_digest D2\n    When I call snapshot.diff(S1,S2)\n    Then diff identity includes a.manifest_digest D1 and b.manifest_digest D2\n    And diff computation uses manifest bytes fetched by those digests\n\n  Scenario: Diff fails when a snapshot reference cannot be resolved\n    Given snapshot_id S_missing does not exist\n    When I call snapshot.diff(S_missing,S2)\n    Then a typed error NotFound is returned\n\n  Scenario: Diff fails when a manifest digest cannot be resolved in CAS\n    Given manifest_digest D_missing does not exist in CAS\n    When I call snapshot.diff(D_missing,D2)\n    Then a typed error MissingBlob is returned\n\n  Scenario: Diff fails fast on malformed manifest bytes\n    Given manifest A bytes are not valid UTF-8 JSON\n    When I compute diff(A,B)\n    Then a typed error InvalidManifest is returned\n\n  Scenario: Diff ignores manifest_digest differences when semantic_manifest_digest is unchanged\n    Given manifest A and manifest B have different manifest_digest values\n    And manifest A and manifest B have identical semantic_manifest_digest\n    When I compute diff(A,B)\n    Then diff classification is \"no_semantic_change\"\n\n  Scenario: Diff reports InvariantViolation when constraints envelope disagrees with projection digests\n    Given manifest A constraints.constraints_digest does not match the canonicalized constraints envelope bytes\n    When I compute diff(A,B)\n    Then an InvariantViolation is reported (and diff still returns)\n\n  Scenario: Diff treats missing constraints envelope as MissingField\n    Given manifest A has no top-level \"constraints\" field\n    When I compute diff(A,B)\n    Then a typed error MissingField is returned\n\n  Scenario: Diff remains deterministic under randomized JSON field order in input\n    Given manifest A and manifest B parse to equivalent JSON objects but have different input key order\n    When I compute diff(A,B)\n    Then the diff output is identical\n"
links:
- parent: ettle:snapshot_commit
  parent_ep: ep:snapshot_commit:0
  child: ettle:snapshot_diff
