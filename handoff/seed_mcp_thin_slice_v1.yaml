schema_version: 0
project:
  name: ettlex

ettles:
- id: ettle:mcp_thin_slice
  title: MCP Thin Slice (Transport-Only; Apply + Queries; Authoring-Grade)
  eps:
  - id: ep:mcp_thin_slice:0
    ordinal: 0
    normative: true
    why: |-
      Dogfooding via seed import is intentionally disposable, but if it remains the primary authoring path it
      will distort the product workflow and accidentally harden seed semantics.

      The MCP layer is the necessary authoring control plane for coding agents: it makes the system callable
      without turning the CLI into the de-facto product interface. To avoid over-engineering, MCP must be a
      thin transport wrapper over the already-stabilised action layer (Apply + Queries), with no new domain
      semantics.

      This seed defines the MCP “authoring-grade thin slice” required to:
        - create/modify Ettles/EPs/links via Apply commands,
        - manage constraint CRUD + EP linking via Apply commands,
        - commit snapshots and compute diffs via the same action surfaces,
        - read canonical state and deterministic projections via action:queries,
        - preserve determinism and governance invariants.
    what: |-
      Implement the MCP server as a transport-only adapter over the canonical application/service layer.

      Implementation dependencies (non-refinement; NOT expressed as multiple parents):
        - store spine (seed_store)
        - snapshot commit pipeline (seed_snapshot_commit_v5)
        - snapshot diff pipeline (seed_snapshot_diff_v6)
        - constraint schema stubs (seed_constraint_schema_stubs_v9)
        - constraint engine slice 0 (seed_constraint_engine_slice0_v1)
        - decision schema stubs (seed_decision_schema_stubs_v2) if decision tools are exposed
        - action read tools (seed_action_read_tools_v3) as the canonical query surface
        - snapshot commit action refactor (seed_snapshot_commit_actions_refactor_v3) if commit is now Apply-only


      Binding architectural constraints (MUST):

        A) MCP is transport, not domain model
           - MCP MUST NOT introduce new semantic rules, validation rules, ordering rules, or projections.
           - MCP MUST only:
               1) validate tool input schema (types, required fields, bounds),
               2) translate tool inputs into command/query DTOs,
               3) call the action layer (commands::apply or queries::*),
               4) translate outputs/errors into tool responses.

        B) Single mutation ingress
           - Every canonical mutation exposed by MCP MUST flow through action:commands::apply.
           - MCP MUST NOT call store/engine mutation functions directly.

        C) Determinism and canonicalisation
           - MCP outputs MUST be deterministic for identical action-layer outputs.
           - Where outputs are serialized (JSON), key ordering MUST be canonicalised.
           - MCP MUST NOT inject timestamps into semantic content (request timestamps may appear in logs only).

        D) Governance threading
           - MCP MUST accept and thread request context (request_id/correlation_id) through to:
               - logging (tracing spans),
               - error taxonomy (stable error_code),
               - action layer policy/profile hooks.
           - MCP MUST allow policy_ref and profile_ref to be passed for operations that support them
             (e.g. SnapshotCommit).

        E) Scale-safety
           - All list-style tools MUST support limit + cursor pagination (or an explicit “not implemented yet” error),
             and MUST enforce a default limit when omitted.

        F) Security and operational posture (Phase 1/early Phase 2)
           - MCP MUST support a minimal dev auth mode (e.g. allowlist token) with explicit “auth disabled” configuration.
           - No complex RBAC is required in this seed; policy decisions remain in the action layer.

      Tool surface (minimum; names are normative for MCP, but must map to existing action surfaces):

        1) Write tool (only mutation tool):
           - ettlex.apply
             Input: { command: <Command>, expected_state_version?, request_context?, policy_ref?, profile_ref? }
             Output: { new_state_version, events?, result? }

           Notes:
             - The command payload MUST be the canonical command vocabulary (no MCP-only commands).
             - expected_state_version (if present) enables optimistic concurrency; mismatches MUST error.

        2) Read/query tools (read-only; must map 1:1 to action:queries):
           - state.get_version
           - ettle.get
           - ettle.list (options: prefix_filter?, title_contains?, limit?, cursor?)
           - ettle.list_eps
           - ep.get
           - ep.list_children
           - ep.list_parents (under one-parent invariant; corruption surfaces as RefinementIntegrityViolation)
           - constraint.get
           - constraint.list_by_family (options include include_tombstoned?, limit?, cursor?)
           - ep.list_constraints
           - decision.get / decision.list / decision.list_by_target / ep.list_decisions / ettle.list_decisions / ept.compute_decision_context (if decision seed is in-scope)
           - snapshot.get
           - snapshot.list (options: ettle_id? leaf_ep_id? limit? cursor?)
           - manifest.get_by_snapshot
           - manifest.get_by_digest
           - ept.compute
           - snapshot.diff (resolves snapshot_id or manifest_digest to manifest bytes; operates on bytes only)

      Error mapping contract (binding):
        - MCP MUST surface action-layer typed errors as stable tool errors:
            { error_code, message, details?, correlation_id }
        - Error codes MUST be stable and testable. MCP MUST NOT collapse all failures into a single generic error.

      Compatibility contract (binding):
        - MCP MUST be implementable without changing the semantic behaviour specified by:
            - snapshot commit pipeline seed
            - snapshot diff seed
            - constraint schema stubs + constraint engine slice 0
            - action read tools seed
        - MCP may add only transport-level schema and wiring.

    how: |-
      Scenarios (all MUST be implemented as tests; unit/integration; Gherkin is normative):

      Feature: MCP thin slice is a transport-only wrapper over action commands and queries

        Background:
          Given the action layer exists with Apply (commands) and Query (read tools)
          And snapshot_commit, snapshot_diff, constraint schema stubs, and constraint engine slice 0 are implemented
          And MCP server is started in dev mode with a valid token "t:dev"

        # --- Transport-only invariant ---

        Scenario: MCP does not implement business logic (delegation only)
          When I call MCP tool ettle.get for ettle_id "ettle:x"
          Then MCP calls the corresponding action query ettle.get with the same id
          And MCP does not perform additional filtering, sorting, or projection beyond schema validation
          And the result bytes are identical to the action query output after canonical JSON serialization

        Scenario: MCP write operations call Apply and nothing else
          When I call MCP tool ettlex.apply with command Command::EttleCreate{...}
          Then MCP calls action:commands::apply exactly once
          And MCP does not call store mutation APIs directly

        # --- Auth / request context ---

        Scenario: MCP rejects missing auth token when auth is enabled
          Given MCP auth is enabled
          When I call any MCP tool without token
          Then a typed error AuthRequired is returned

        Scenario: MCP accepts token and threads correlation_id
          When I call ettlex.apply with request_context{correlation_id="c:1"}
          Then the action layer receives correlation_id "c:1"
          And any produced error includes correlation_id "c:1"

        # --- Apply tool: schema validation ---

        Scenario: Apply rejects unknown command tag
          When I call ettlex.apply with command { tag="Command::Nope", ... }
          Then a typed error InvalidCommand is returned

        Scenario: Apply rejects missing required fields
          When I call ettlex.apply with command Command::EpCreate missing "ep_id"
          Then a typed error InvalidInput is returned
          And no Apply call is executed

        Scenario: Apply rejects oversized payloads
          Given MCP max_request_bytes is configured to 1MB
          When I call ettlex.apply with a payload exceeding 1MB
          Then a typed error RequestTooLarge is returned

        # --- Apply tool: optimistic concurrency ---

        Scenario: Apply enforces expected_state_version if supplied
          Given current state_version is V10
          When I call ettlex.apply with expected_state_version=V9
          Then a typed error HeadMismatch is returned
          And no mutation occurs

        Scenario: Apply returns new_state_version on success
          Given current state_version is V10
          When I call ettlex.apply with a valid mutation command
          Then response includes new_state_version V11

        # --- Query tools: non-mutation invariant ---

        Scenario: Query tools do not mutate canonical state
          Given state_version is V20
          When I call a representative set of query tools (ettle.list, ep.get, ept.compute, snapshot.diff)
          Then state_version remains V20
          And no ledger rows are appended
          And no CAS blobs are written

        # --- Query tools: scale safety (pagination) ---

        Scenario: ettle.list enforces default limit and returns cursor
          Given 500 Ettles exist
          When I call MCP ettle.list() with no options
          Then at most the default limit of results is returned
          And a cursor is returned when additional results exist

        Scenario: ettle.list supports cursor-based pagination deterministically
          Given 500 Ettles exist
          When I call MCP ettle.list(limit=100)
          Then I receive 100 results and cursor_1
          When I call MCP ettle.list(limit=100, cursor=cursor_1)
          Then I receive the next 100 results and cursor_2
          And there are no duplicates across pages
          And repeating the same calls returns identical pages

        Scenario: snapshot.list enforces default limit and supports cursor
          Given 300 snapshots exist
          When I call MCP snapshot.list() with no options
          Then at most the default limit is returned
          And a cursor is returned if more exist

        # --- Determinism of MCP serialization ---

        Scenario: MCP emits canonical JSON with stable key ordering
          When I call MCP ettle.get twice for the same ettle_id without state change
          Then the raw JSON bytes are identical

        Scenario: MCP determinism failure is detected by tests
          Given code changes that emit JSON with unstable key ordering
          When I call MCP ettle.get twice
          Then the determinism test fails with DeterminismViolation

        # --- Snapshot commit via MCP (end-to-end authoring loop) ---

        Scenario: Agent can author via MCP and commit snapshot (leaf scoped)
          Given a valid leaf EP exists
          When I call ettlex.apply with Command::SnapshotCommit{leaf_ep_id=...}
          Then a snapshot_id is returned
          And manifest is written to CAS
          And ledger is appended

        Scenario: MCP surfaces NotALeaf from action layer
          Given EP exists but is not a leaf
          When I call ettlex.apply with Command::SnapshotCommit{leaf_ep_id=that EP}
          Then the tool returns error_code NotALeaf

        Scenario: MCP surfaces policy denial without mutation
          Given policy denies snapshot commit
          When I call ettlex.apply with Command::SnapshotCommit{leaf_ep_id=..., policy_ref="policy/deny@0"}
          Then error_code PolicyDenied is returned
          And no ledger row is appended

        # --- Snapshot diff via MCP (read-only, manifest-bytes only) ---

        Scenario: snapshot.diff resolves snapshot_id refs to manifest bytes and does not read canonical DB for semantics
          Given snapshots S1 and S2 exist
          When I call MCP snapshot.diff(S1,S2)
          Then diff identity includes the corresponding manifest digests
          And the diff result matches action query output
          And no canonical DB reads are performed for semantic comparison (manifest bytes only)

        Scenario: snapshot.diff fails for missing snapshot reference
          When I call MCP snapshot.diff("snapshot:missing", S2)
          Then error_code NotFound is returned

        Scenario: snapshot.diff fails for missing CAS blob
          Given snapshot S1 references a missing manifest blob in CAS
          When I call MCP snapshot.diff(S1,S2)
          Then error_code MissingBlob or StorageError is returned

        # --- Constraint authoring via MCP (CRUD + linking) ---

        Scenario: Create constraint and attach via MCP; snapshot shows declared constraint refs
          Given leaf_ep_id closure contains ep:x
          When I call ettlex.apply Command::ConstraintCreate{constraint_id="c:1", family="vendor_ext", payload={...}}
          And I call ettlex.apply Command::ConstraintAttachToEp{ep_id="ep:x", constraint_id="c:1"}
          And I commit snapshot for that leaf_ep_id
          Then manifest.constraints.declared_refs includes "c:1"
          And manifest.constraints.families["vendor_ext"].status is UNCOMPUTED

        Scenario: MCP rejects constraint create missing family (schema validation or action error)
          When I call ettlex.apply Command::ConstraintCreate{constraint_id="c:2", family="", payload={...}}
          Then error_code InvalidConstraintFamily is returned

        Scenario: MCP rejects duplicate attachment
          Given "c:1" is already attached to ep:x
          When I call ettlex.apply Command::ConstraintAttachToEp{ep_id="ep:x", constraint_id="c:1"}
          Then error_code DuplicateAttachment is returned

        # --- Boundary conditions ---

        Scenario: MCP handles large read responses with truncation policy
          Given an ettle.list_eps response would exceed 2MB
          When I call MCP ettle.list_eps(ettle_id)
          Then MCP enforces configured response limits
          And returns either a paginated response or a typed error ResponseTooLarge (implementation choice; must be stable)

        Scenario: MCP rejects unknown tool name
          When I call MCP tool "not.a.tool"
          Then error_code ToolNotFound is returned

        Scenario: MCP rejects invalid cursor
          When I call ettle.list(cursor="not-a-cursor")
          Then error_code InvalidCursor is returned

links:
- parent: ettle:action_read_tools
  parent_ep: ep:action_read_tools:0
  child: ettle:mcp_thin_slice
